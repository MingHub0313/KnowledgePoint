package com.base.page20;

import com.base.page17.BaseDataTest;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @Name CharacterTest
 * @Author 900045
 * @Created by 2020/10/27 0027
 */
public class CharacterTest {
	/**
	 * 重写	-- 发生在父子类中.可以说子类重新定义了父类的方法.重写必须有相同的方法名 参数列表 和返回类型
	 * 		1.不能存在同一个类中 .存在于 继承 或 实现关系中;
	 * 		2.方法名相同 参数列表相同 返回值相同;
	 * 		3.子类方法的访问修饰符要大于父类的;
	 * 		4.子类的检查异常类型要小于父类的检查异常.
	 * 重载	-- 发生在同一类里面两个或者多个方法的方法名相同但参数不同的情况
	 *		1.可以在一个类中也可以在继承关系的类中;
	 *		2.名相同;
	 *		3.参数类型不同(个数、顺序、类型) 和方法的返回值类型无关.
	 *
	 * 封装
	 * 	封装的两大原则 : 1).把尽可能多的东西藏起来,对外提供简洁的接口; 2).把所有的属性封装起来.
	 * 	封装的优点:
	 * 				1).便于使用者正确、方便的使用系统,防止使用者错误修改系统属性;
	 * 				2).有助于建立各个系统之间的松耦合关系;
	 * 				3).	提高软件的可重用性;
	 * 				4).降低了大型系统的风险,即便整个系统不成功,个别子系统有可能用的价值.
	 * 继承
	 * 		好处:
	 * 			1).子类能自动继承父类的接口;
	 * 			2).创建子类的对象时,无须创建父类的对象.
	 * 		坏处:
	 * 			1).	破坏封装,子类与父类之间紧密耦合,子类依赖于父类的实现,子类缺乏独立性;
	 * 			2).	支持扩展,但是往往以增加系统结构的复杂度为代价;
	 * 			3).不支持动态继承.在运行时 子类无法选择不同的父类;
	 * 			4).子类不能改变父类的接口.
	 * 多态
	 * 	多态的理解（实现方式）
	 * 		方法重载(overload):实现的是编译时的多态性(前绑定);
	 * 		方法重写(override):实现的是运行时的多态性(后绑定).
	 * 		要实现多态需要做两件事情:
	 * 								1.方法重写 -- 子类集成父类并重写父类中已有的或抽象方法
	 * 								2.对象构造 -- 用父类型指向子类型对象,这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为
	 */

	private Logger log= LoggerFactory.getLogger(CharacterTest.class);

	/**
	 * Java 的四个基本特性 :
	 * 	1.抽象 -- 将一类对象的共同特征总结出来构造类的过程.		[只关注属性和行为,并不关注这些行为的细节是什么]
	 * 	2.继承 -- 继承是从已有类得到继承信息创建新类的过程.		提供继续信息的类被称为父类[超类 基类];得到继承信息的类被称为子类[派生类]
	 * 			  继承让变化中的软件系统有了一定的延续性,同时继承也是封装程序中可变因素的重要手段.
	 * 	3.封装 -- 隐藏对象的属性和实现细节仅仅对外公开接口.		面向对象的本质就是将现实世界描绘成一系列完全自治 封闭的对象.
	 * 	4.多态 -- 允许不同子类的对象对同一消息作出不同的响应. 某个类型引用变量引用子类的实例,而且可以对这个引用变量进行类型转换.
	 */

	/**
	 * Question 1.Java中是否可以覆盖一个 private  或者 static 的方法?
	 * Java 中 static 方法不能被覆盖 因为方法覆盖是基于运行时动态绑定的,而 static 方法是编译时静态绑定的. static 方法跟类的任何实例都不相关
	 * Java 中也不可以覆盖 private 的方法 因为 private 修饰的变量和方法只能在当前类中使用,如果其他的类继承当前类是不能访问到 private 变量或方法
	 */
	@Test
	public void test(){

	}
}
