package com.base.page20;

import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;

/**
 * @Name CharacterTest
 * @Author 900045
 * @Created by 2020/10/27 0027
 */
public class CharacterTest {
	/**
	 * 重写	-- 发生在父子类中.可以说子类重新定义了父类的方法.重写必须有相同的方法名 参数列表 和返回类型
	 * 		1.不能存在同一个类中 .存在于 继承 或 实现关系中;
	 * 		2.方法名相同 参数列表相同 返回值相同;
	 * 		3.子类方法的访问修饰符要大于父类的;  【子类不能降低其父类的方法访问权限】
	 * 		如果在父类中的是 public 的方法,子类将其降低访问权限为 private 那么子类中重写以后的方法外部对象就不可访问---破坏了继承的含义
	 * 		4.子类的检查异常类型要小于等于父类的检查异常. 【运用多态性的原理】 ---  编译看左边  运行看右边.	执行的是子类中重写的方法
	 * 		如果子类抛出的异常无法被父类接收(即子类抛出的异常大于 try catch 中的异常,那么是无法处理异常,无法接收)
	 * 重载	-- 发生在同一类里面两个或者多个方法的方法名相同但参数不同[个数,顺序 类型不同]的情况
	 *		1.可以在一个类中也可以在继承关系的类中;
	 *		2.名相同;
	 *		3.参数类型不同(个数、顺序、类型) 和方法的返回值类型无关.
	 *
	 * 封装
	 * 	封装的两大原则 : 1).把尽可能多的东西藏起来,对外提供简洁的接口; 2).把所有的属性封装起来.
	 * 	封装的优点:
	 * 				1).便于使用者正确、方便的使用系统,防止使用者错误修改系统属性;
	 * 				2).有助于建立各个系统之间的松耦合关系;
	 * 				3).提高软件的可重用性;
	 * 				4).降低了大型系统的风险,即便整个系统不成功,个别子系统有可能用的价值.
	 * 继承
	 * 		好处:
	 * 			1).子类能自动继承父类的接口;
	 * 			2).创建子类的对象时,无须创建父类的对象.
	 * 		坏处:
	 * 			1).	破坏封装,子类与父类之间紧密耦合,子类依赖于父类的实现,子类缺乏独立性;
	 * 			2).	支持扩展,但是往往以增加系统结构的复杂度为代价;
	 * 			3).不支持动态继承.在运行时 子类无法选择不同的父类;
	 * 			4).子类不能改变父类的接口.
	 * 多态
	 * 	多态的理解（实现方式）
	 * 		方法重载(overload):实现的是编译时的多态性(前绑定);
	 * 		方法重写(override):实现的是运行时的多态性(后绑定).
	 * 		要实现多态需要做两件事情:
	 * 								1.方法重写 -- 子类继承父类并重写父类中已有的或抽象方法
	 * 								2.对象构造 -- 用父类型指向子类型对象,这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为
	 */

	private Logger log= LoggerFactory.getLogger(CharacterTest.class);

	/**
	 * Java 的四个基本特性 :
	 * 	1.抽象 -- 将一类对象的共同特征总结出来构造类的过程.		[只关注属性和行为,并不关注这些行为的细节是什么]
	 * 	2.继承 -- 继承是从已有类得到继承信息创建新类的过程.		提供继续信息的类被称为父类[超类 基类];得到继承信息的类被称为子类[派生类]
	 * 			  继承让变化中的软件系统有了一定的延续性,同时继承也是封装程序中可变因素的重要手段.
	 * 	3.封装 -- 隐藏对象的属性和实现细节仅仅对外公开接口.		面向对象的本质就是将现实世界描绘成一系列完全自治 封闭的对象.
	 * 	4.多态 -- 允许不同子类的对象对同一消息作出不同的响应. 某个类型引用变量引用子类的实例,而且可以对这个引用变量进行类型转换.
	 */

	/**
	 * Question 1.Java中是否可以覆盖一个 private  或者 static 的方法?
	 * Java 中 static 方法不能被覆盖 因为方法覆盖是基于运行时动态绑定的,而 static 方法是编译时静态绑定的. static 方法跟类的任何实例都不相关
	 * Java 中也不可以覆盖 private 的方法 因为 private 修饰的变量和方法只能在当前类中使用,如果其他的类继承当前类是不能访问到 private 变量或方法
	 */
	@Test
	public void test(){
		/*CharacterTest characterTest = new CharacterTest();
		characterTest.display(new SuperClass());*/


		SuperClass superClass = new SubClass();
		try{
			superClass.method();
			/**
			 * 在编译过程中 superClass.method() 时 可以认为引用的父类中的方法
			 * 因此此时会抛出 IO异常,在 catch语句中进行处理;
			 * 在运行的时候,此时引用的子类中的方法,会抛出 FileNotFoundException异常
			 * 但 catch 中的异常处理IO异常包括了 该异常,相当于一同处理了,因此程序能够运行
			 *
			 * 如果此时反过来,也就是子类抛出的异常比父类的异常大
			 * 子类抛出的异常是IO异常 由于catch 中处理的是 FileNotFoundException异常
			 * 那么在运行的时候,IO异常将无法解决,就会出现错误.
			 */
		}catch (IOException e) {
			e.printStackTrace();
		}


	}

	public void display(SuperClass s){
		try {
			s.method();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
